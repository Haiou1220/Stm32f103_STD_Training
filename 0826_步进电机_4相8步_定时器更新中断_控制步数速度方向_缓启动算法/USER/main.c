/**
  ******************************************************************************
 项目介绍：
 步进电机28BYJ-48，实现了指定角度或者步数的执行，可以更改其执行速度，方向。有阻塞接口和非阻塞接口对外提供，有缓启动缓停止的算法，通过
 步数将前N步与后N步的延时时间线性增加或者减少，在平稳阶段全速800Hz运行。丢步现象减少发生。
步进电机28BYJ-48 4相5线,步进角度5.625*减速比(1/64) ;48:表示4相8拍  
4相可以有多种步数，一般使用8步数
本项目利用定时器7 作为 定时中断用于调节 步进电机速度

驱动方法两种：
1.发送8个循环形成8步，每一步 分别改变ABCD 的电平，延时的快慢的改变就是其 运动速度
2.用一个定时器更新中断来延时，改变其ARR值改变其速度， 完成所有步 关闭全部线圈，
 
技术实现概述：采用定时器的更新中断， 配置gpio和时基单元，中断向量配置，
最要注意的是开启更新中断使能之前要清空其SR寄存器的值，时基的计数频率设为1us，
在steppper_motor文件中定义3个步进电机的变量，（需要步数，需要的方向，步延时时间）
最后在中断里面调用回调函数，回调函数定义在steppper_motor文件中，
回调函数要非阻塞执行，函数变量保存当下的状态，下一次中断来继续执行，直到步数完成，重置所有记忆变量

注意：开启定时器TIM_IT_Update中断 之前，一定要TIM_ClearITPendingBit(TIM2,TIM_IT_Update);  清除SR标志寄存器状态位，虽然定时器还没有使能，中断依然发生
	//开启定时器2更新中断前 ,清除标志位，再使能中断
	 TIM_ClearITPendingBit(TIM2,TIM_IT_Update);
	//开启中断
	TIM_ITConfig(  TIM2,  TIM_IT_Update,  ENABLE);
不足地方：1.要改善加减速算法 2.外加传感器在上电初始化找零点位置


  
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "stm32f10x.h"
#include "stdio.h"
#include "global.h"
#include "systick.h"//延时定时器
#include "timer.h"//定时器2 1ms中断 作为任务定时
#include "usart.h"//串口1 串口助手
#include "led.h"
#include "dma_usart.h"  //串口1dma
#include "pwm_servo.h"  //串口1dma
#include "ic_timer.h"   //定时器4输入捕获
#include "stepper_motor.h"   //步进电机

/*Compiler definec : USE_STDPERIPH_DRIVER,STM32F10X_MD */
/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/




/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
 

  
 //------------------------系统全局变量头文件对外声明---------------------------------------- 
//  串口命令任务 ，串口命令 字符标志位
 u8 gFlagUsartCMD_0,gFlagUsartCMD_1,gFlagUsartCMD_2,gFlagUsartCMD_3,gFlagUsartCMD_4,gFlagUsartCMD_5,gFlagUsartCMD_6,gFlagUsartCMD_7,gFlagUsartCMD_8,gFlagUsartCMD_9;
   // 定时任务标志位
  uint8_t gFlagTime_1MS;
  
  u8 gDebug_u8;  //调试
  u16 gDebug_u16; //调试 
  
  
  
   

 //------------------------系统全局变量头文件对外声明----------------------------------------
 
 

//--------------------------------------全局静态static变量区 	---------------------------------------------------

 


//--------------------------------------全局静态static变量区 	---------------------------------------------------
	



int main(void)
{
//------------------------主函数局部变量区----------------------  
//定时任务  计时器 标志位
 uint8_t  FlagTime_nMS,FlagTime_500MS,FlagTime_1Sec,FlagTime_3Sec;
 

 
	
//------------------------主函数局部变量区----------------------
	
	
 

////////////////////////////   
  NVIC_PriorityGroupConfig(  NVIC_PriorityGroup_2);//配置中断分组2(2bit:2bit)
  sysTick_init();//初始化systick
	usart1_init(115200 ) ;//pa9 tx,  pa10 rx,,,接收中断: 
  timer2_countdown_init();   //配置定时器2为基准的任务计时 disable
  Led1_Off;	
  Led0_Off;	
/////////////////////
	Info( SYSTEM IS STAR UP); //打印系统启动提示
////////////////////
//------------------------初始化函数区----------------------	
	 
	
 
 gpio_output_steperMotor_Uln2003_init()	; //PE0_1_2_3 

 steperMotor_Uln2003_run_timerUp_interrupt_init( );	  //定时器7 定时中断 执行步进电机步数
 

  		 
		//printf("MAIN  ---TIM7->ARR%#06x ,TIM7->CNT:%#06x，TIM7->SR:%#06x \r\n", TIM7->ARR,TIM7->CNT,TIM7->SR);调试
	

//------------------------初始化函数区----------------------	
 while ( 1 ) {
	 
  
	 
	//////////////////////-----------------------串口命令任务---------------------------------------//////////////////
 	if(gFlagUsartCMD_0 == SET)
 	{
		gFlagUsartCMD_0 = RESET;
	////////////////

	 
		
    ///////////////////////////////////////////////////////////////////////////////////
	}

	if(gFlagUsartCMD_1 == SET)
 	{
		gFlagUsartCMD_1 = RESET;
	/////////////////////////////////////////////////
	
		u32 reg1,reg2,reg3 ;   
		reg1 = TIM7->ARR;
		reg2 = TIM7->CNT;
		reg3 = TIM7->SR;
		printf("TIM7->ARR%#06x ,TIM7->CNT:%#06x，TIM7->SR:%#06x \r\n",reg1,reg2,reg3); //查看寄存器值
	///////////////////////////////////////////////////////////////////////////////////	
	}
	
	if(gFlagUsartCMD_2 == SET)
 	{
		gFlagUsartCMD_2 = RESET;
		//////////////////////////////
	
									
    ///////////////////////////////////////////////////////////////////////////////////
	}

	
	if(gFlagUsartCMD_3 == SET)
	{
		gFlagUsartCMD_3 = RESET;
	 //////

	
		
		
    //////////////////////////////////////////////////////////////////////////////////////////		
	}
	
	if(gFlagUsartCMD_4 == SET)
	{
		gFlagUsartCMD_4 = RESET;
		//////////////////
	
	 
		
   ///////////////////////////////////////////////////////////////////////////////////		
	}
	
	if(gFlagUsartCMD_5 == SET) //
	{
		gFlagUsartCMD_5 = RESET;
		/////
	
		
		
	///////////////////////////////////////////////////////////////////////////////////
	}
	
	if(gFlagUsartCMD_6 == SET) //
	{
		gFlagUsartCMD_6 = RESET;
		////
		

		
		
		
	///////////////////////////////////////////////////////////////////////////////////		
	}
	if(gFlagUsartCMD_7 == SET) ////
	{
		gFlagUsartCMD_7 = RESET;
		//////
 
	 
	  steperMotor_Uln2003_run_Nstep_Blocking (  1024*4, 1 , 1250);	  //定时器延时查询  阻塞的，不建议使用// //  1250 MS = 800HZ ,2000MS = 500HZ, 10000 MS=1OOHZ  
		
	
		
		
///////////////////////////////////////////////////////////////////////////////////			 
	}	
	if(gFlagUsartCMD_8 == SET) //// 
	{
		gFlagUsartCMD_8 = RESET;
		//////
     	
		
		

		 steperMotor_Uln2003_run_Angle_StartTask(  360,  1); //定时器延时中断  非阻塞的，建议使用
	 
		
		
///////////////////////////////////////////////////////////////////////////////////		 
	}
	if(gFlagUsartCMD_9 == SET) 
	{
		gFlagUsartCMD_9 = RESET;
	//////////////////
 
		  steperMotor_Uln2003_run_Angle_StartTask(  360,  0);//定时器延时中断  非阻塞的，建议使用
 
 
	 
////////////////////////////////////////////////////////////////////////////////////////////////	
	}
	
  
	
	
	
/***************************************定时 Nms任务*************************************************************/ 
	if(FlagTime_nMS)
	{
		FlagTime_nMS = RESET;  		////////// Nms
		////////////////
		//ms
	
		
	}
/***************************************定时0.5S 任务*************************************************************/ 	
	////0.5s-任务
	if(FlagTime_500MS)
	{
	FlagTime_500MS = RESET;
		//////////
			
		
	}
/***************************************定时 1S任务*************************************************************/ 
	////1s-任务
	if(FlagTime_1Sec)
	{	
		static uint8_t TIME_COUNT; //默认为0
		FlagTime_1Sec = RESET;
		TIME_COUNT++;
		if(TIME_COUNT % 3 == 2 ){  FlagTime_3Sec = SET;  }   //余 0 1 2
		if(TIME_COUNT>=255) { TIME_COUNT = 0; }
		////////////////////////////////////////////////////
		

		
		
 /***************************************定时 3S任务*************************************************************/ 		
	}	
	////3s-任务
	if(FlagTime_3Sec)
	{
		FlagTime_3Sec = RESET;
		/////////////////////////////////////////////////
 
	   
	}
	 
/***************************************定时 任务*************************************************************/ 	
	//定时器2计数任务
	if( gFlagTime_1MS == SET ) 
	{	
		static uint16_t count1000,countN,count500; //局部静态默认为0
		gFlagTime_1MS = RESET;
		count1000++;
		countN++;
		count500++;
		if(countN>=   1  )  //自定义 ms
		{
			countN = 0;
			FlagTime_nMS = SET;
		}
		if(count500>=500)  //0.5S任务标志位
		{
			count500 = 0;
			FlagTime_500MS = SET;
		}
		if(count1000>=1000)  ////1S任务标志位，，，闭区间0................1000开区间
		{
			count1000 = 0;
			FlagTime_1Sec = SET;
		}
	 }
	
	 

 }//WHILE
}//MAIN




